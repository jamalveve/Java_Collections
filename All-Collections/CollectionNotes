https://www.javatpoint.com/java-collections-interview-questions
When to Use an Iterator
Removing Elements: If you need to remove elements from the collection during iteration, you should use an Iterator. The Iterator provides a safe way to remove elements using the remove() method, preventing ConcurrentModificationException.

Example: Removing specific elements from a collection based on some condition.

More Control: If you need more control over the iteration process, such as skipping elements or iterating backward, Iterator is more flexible.

Generic Use Cases: In some cases where you need to perform complex logic while iterating, using an Iterator might be cleaner and more understandable.

When to Use a For-Each Loop
Simplicity and Readability: The enhanced for-loop is generally more concise and easier to read, especially when you don’t need to remove elements or manipulate the iteration process.

Example: Just iterating through all elements in a collection without needing to modify it.

Performance: For most collections, the performance difference is negligible for simple iteration. The enhanced for-loop can be slightly more efficient due to less overhead than creating an Iterator object, though this is often minimal.

No Removal or Modification: If you are just iterating through the elements for reading or processing without any need to modify the collection, the enhanced for-loop is preferred.

Advantages of Each Approach
Advantages of Using an Iterator
Safe Removal: The ability to remove elements during iteration without throwing exceptions.
Flexibility: Greater control over the iteration process (e.g., modifying the flow).
Works with All Collections: Iterator can be used with any collection that implements the Iterable interface.
Advantages of Using a For-Each Loop
Simplicity: More concise syntax that improves code readability.
Less Boilerplate: Less code to write compared to using Iterator, which can make maintenance easier.
Direct Access to Elements: Directly accessing elements without needing to call next().
1)Set:
***********
When to Use a Set
Unique Elements: When you want to store only unique values and automatically avoid duplicates. For example, if you're collecting user IDs or email addresses.

Fast Lookup: When you need to check for the existence of an element quickly. HashSet provides average O(1) time complexity for lookups.

Mathematical Set Operations: When you need to perform operations like union, intersection, and difference between collections.

Unordered Collection: When the order of elements does not matter. A HashSet does not maintain any order, while a LinkedHashSet maintains insertion order.

Performance: When you need better performance for add, remove, and contains operations compared to a list, especially when the collection size is large.

When Not to Use a Set
Ordered Collection: If you need to maintain the order of elements or allow duplicates, use a List (like ArrayList) instead.

Indexed Access: If you need to access elements by index, a Set is not suitable, as it does not provide indexed access.

Synchronization: If you need thread safety, consider using Collections.synchronizedSet() around a Set, or use a CopyOnWriteArraySet for concurrent modifications.

HashSet
***********
above all applies

Linked HashSet speciality
*****************

Maintains Insertion Order: Unlike HashSet, which does not guarantee any order,
 LinkedHashSet maintains the order in which elements are added.
 When you iterate over a LinkedHashSet, the elements are returned in their insertion order.
  
It combines the benefits of a hash table (for quick access and performance) with the advantages of a linked list (for insertion iteration order).
 
TreeSet Speciality
 ****************
Sorted Order: TreeSet maintains its elements in a sorted (ascending) order. The order can be determined by the natural ordering of the elements or by a custom comparator provided at the time of set creation.
Null Elements: A TreeSet does not allow null elements. If you attempt to add a null element, it will throw a NullPointerException. 


https://www.scientecheasy.com/2022/07/set-interview-questions.html/


Choose LinkedHashSet:

Maintaining a unique set of user preferences in the order they were set.
Storing the history of user actions where the order of actions matters.
Implementing a cache with a predictable iteration order for elements.
Choose HashSet:

Storing a unique collection of IDs where the order of insertion does not matter.
Checking for the existence of elements in a large dataset without concern for ordering.
Performance-sensitive applications where memory usage is a key factor and order is irrelevant.

Hashset:->

Constructors of HashSet
!)Default Constructor
^^^^^^^^^^^^^^^^^^^

java
Copy code
HashSet<HashSetType>() 
Description: Creates a new, empty HashSet with a default initial capacity (16) and load factor (0.75).
Ex:
HashSet<String> set = new HashSet<>();

2)Constructor with Initial Capacity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

HashSet(int initialCapacity) 
Description: Creates a new, empty HashSet with the specified initial capacity and a default load factor (0.75).
Parameters:
initialCapacity: The initial capacity of the HashSet.
Example:

HashSet<String> set = new HashSet<>(32); // Initial capacity of 32

While a HashSet will grow automatically, providing an initial capacity is a useful strategy to enhance performance, optimize memory usage, and control resource allocation, especially when dealing with a known number of elements. This proactive approach can lead to a more efficient application, especially in scenarios where performance is critical.
if yu have more data to be stores around 1000 so if you init it, it is less likely to resize frequently, ,so resulting in faster performance.


3)Constructor with Initial Capacity and Load Factor
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Load Factor= 
Number of Buckets/
Number of Elements

The load factor:-in the context of a HashSet (and generally in hash tables) is a measure that determines when the hash table should be resized. It plays a critical role in balancing memory usage and performance. Here’s a detailed explanation of what load factor means:
​

HashSet(int initialCapacity, float loadFactor) 
Description: Creates a new, empty HashSet with the specified initial capacity and load factor.


Parameters:
initialCapacity: The initial capacity of the HashSet.
loadFactor: The load factor for the HashSet.
Example:
java
Copy code
HashSet<String> set = new HashSet<>(32, 0.75f); // Initial capacity of 32 and load factor of 0.75


Let’s see how load factor works in a practical example:

Initialization:

HashSet<String> set = new HashSet<>(10, 0.75f);

Capacity and Load Factor:

Initial Capacity = 10
Load Factor = 0.75
Threshold for resizing = 
10 × 0.75=7.5
(meaning it will resize when trying to add the 8th element).
Adding Elements:

Adding 7 elements will not trigger a resize:

set.add("Apple");  // 1
set.add("Banana"); // 2
set.add("Cherry"); // 3
set.add("Date");   // 4
set.add("Elderberry"); // 5
set.add("Fig");    // 6
set.add("Grapes"); // 7

Adding the 8th element:

set.add("Honeydew"); // This will trigger a resize
Resizing:
When the 8th element is added, the underlying array will resize (typically doubling its capacity to 20), 
and all existing elements will be rehashed to the new array.
4)Constructor with Another Collection
**************************************

HashSet(Collection<? extends E> c) 
Description: Creates a new HashSet that contains the elements of the specified collection. The HashSet is created with a default initial capacity and load factor.
Parameters:
c: Collection whose elements are to be placed into the HashSet.
Example:

List<String> list = Arrays.asList("Apple", "Banana", "Cherry");
HashSet<String> set = new HashSet<>(list); // Contains elements from the list
Summary
^^^^^^^^^^^^
Default Constructor: Creates an empty HashSet with a default capacity and load factor.
Constructor with Initial Capacity: Allows you to specify the initial size of the HashSet.
Constructor with Initial Capacity and Load Factor: Lets you customize both the initial size and the load factor.


Constructors of LinkedHashSet:-4
********************************

remember:lhs dont have remove method
1)Default Constructor:
^^^^^^^^^^^^^^^^^^^^^^^^
LinkedHashSet<Type> set = new LinkedHashSet<>();
This creates an empty LinkedHashSet with the default initial capacity (16) and a load factor of 0.75.
Constructor with Collection: Initializes a HashSet with elements from another collection.

2)Constructor with Initial Capacity:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
LinkedHashSet<Type> set = new LinkedHashSet<>(int initialCapacity);

3)Constructor with Initial Capacity and Load Factor:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
LinkedHashSet<Type> set = new LinkedHashSet<>(int initialCapacity, float loadFactor);

4)Constructor with Another Collection:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
LinkedHashSet<Type> set = new LinkedHashSet<>(Collection<? extends Type> c);


TreeSet
**************

Key Features of TreeSet
Sorted Order:
^^^^^^^^^^^^^^

TreeSet maintains its elements in a sorted order. When you iterate through a TreeSet, the elements will be retrieved in ascending order (or in the order defined by a custom comparator if provided).
NavigableSet Interface:
^^^^^^^^^^^^^^^^^^^^^^^^

TreeSet implements the NavigableSet interface, which means it provides methods for retrieving elements in a sorted manner (e.g., methods like first(), last(), higher(), lower(), etc.).
Performance:
^^^^^^^^^^^^^^^^^^

The basic operations (add, remove, and contains) in a TreeSet have a time complexity of O(log n) because it is implemented as a red-black tree (a type of self-balancing binary search tree).
No Duplicates:
^^^^^^^^^^^^^^^^^

Like all sets, TreeSet does not allow duplicate elements.
Null Elements:
^^^^^^^^^^^^^^^^^

TreeSet does not allow null elements because it relies on the natural ordering of elements. Attempting to add null will throw a NullPointerException.

When to Use TreeSet
************************
Sorted Data:-> Use TreeSet when you need to maintain a collection of elements in sorted order. For example, if you want to store a list of names in alphabetical order or maintain a range of numbers.

Range Queries: ->When you need to perform range queries efficiently, TreeSet allows you to easily find elements within a specified range.

Navigation Methods: ->Use TreeSet when you need methods for accessing the nearest elements (like higher(), lower(), first(), and last()).


when to use Iterator and spliterator?
***************************************
split
********
The main feature of a Spliterator is its ability to "split" a collection into smaller parts for parallel processing. 


 It was introduced in Java 8 a
